---
layout:     post
title:      "ES6——let和const命令"
subtitle:   "let和const命令"
date:       2019-05-13
author:     "Deshan Shi"
tags:       [Javascript，ES6]
categories : [前端]
header-img: "/img/post/post-bg-js-version.jpg"
description: "let和const命令"
---

## 目录
{: .no_toc}

* 目录
{:toc}

## let

### 块级作用域

let所声明的变量，**只在let命令所在的代码块内有效**，在代码块之外调用这个变量，let声明的变量报错；

for循环的计数器，就很合适使用let命令。

eg1：

	var a = [];
	for (var i = 0; i < 10; i++) {
	  a[i] = function () {
	    console.log(i);
	  };
	}
	a[6](); // 10

上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10.

eg2：

	var a = [];
	for (let i = 0; i < 10; i++) {
	  a[i] = function () {
	    console.log(i);
	  };
	}
	a[6](); // 6

上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。

### for循环中的let

for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

eg：

	for (let i = 0; i < 3; i++) {
	  let i = 'abc';
	  console.log(i);
	}
	// abc
	// abc
	// abc

上面代码正确运行，输出了 3 次abc。这表明**函数内部的变量i与循环变量i不在同一个作用域**，有各自单独的作用域。

### 不存在变量提升

var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined；let命令改变了语法行为，**没有变量提升**，它所声明的变量一定要在声明后使用，否则报错。

### 暂时性死区

> 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

eg：
	
	var tmp = 123;
	
	if (true) {
	  tmp = 'abc'; // ReferenceError
	  let tmp;
	}

ES6 明确规定，如果区块中存在**let和const命令**，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。**凡是在声明之前就使用这些变量，就会报错**。

有些“死区”比较隐蔽，不太容易发现：

	function bar(x = y, y = 2) {
	  return [x, y];
	}
	
	bar(); // 报错

上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。

### 不允许重复声明

let不允许在相同作用域内，重复声明同一个变量。

## ES6的块级作用域

内层作用域可以定义外层作用域的同名变量；

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数（函数声明会提升）；

块级作用域内部，优先使用函数表达式，不建议使用函数声明语句；

ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

## const命令

### 特性

> + const声明一个只读的常量，一旦声明，常量的值就不能改变。改变常量的值会报错。
> + 对于const来说，只声明不赋值，就会报错。
> + const的作用域与let命令相同：只在声明所在的块级作用域内有效。
> + const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
> + const声明的常量，也与let一样不可重复声明。

eg:

	var message = "Hello!";
	let age = 25;
	
	// 以下两行都会报错
	const message = "Goodbye!";
	const age = 30;

### 本质

const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，**const只能保证这个指针是固定的**（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。

eg1：
	
	const foo = {};
	
	// 为 foo 添加一个属性，可以成功
	foo.prop = 123;
	foo.prop // 123
	
	// 将 foo 指向另一个对象，就会报错
	foo = {}; // TypeError: "foo" is read-only

上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

eg2：

	const a = [];
	a.push('Hello'); // 可执行
	a.length = 0;    // 可执行
	a = ['Dave'];    // 报错

上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。

如果真的想将对象冻结，应该使用**Object.freeze**方法。

## ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：**var命令和function命令**。ES6 除了添加**let和const命令**，后面章节还会提到，另外两种声明变量的方法：**import命令和class命令**。

## 顶层对象的属性

顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。

	//ES5环境
	window.a = 1;
	a // 1
	
	a = 2;
	window.a // 2

window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，是JS语言的败笔之一。

ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

eg：

	var a = 1;
	// 如果在 Node 的 REPL 环境，可以写成 global.a
	// 或者采用通用方法，写成 this.a
	window.a // 1
	
	let b = 1;
	window.b // undefined

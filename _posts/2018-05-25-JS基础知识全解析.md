---
layout:     post
title:      "JS基础知识全解析"
subtitle:   "总体概述JS的基础知识"
date:       2018-05-25
author:     "Deshan Shi"
tags:       [Javascript]
categories : [前端]
header-img: "/img/post/post-bg-js-version.jpg"
description: "JS中的知识点比较多，在这里对它们进行归纳总结，方便以后查阅"
---

## 目录
{: .no_toc}

* 目录
{:toc}

## 调用栈

调用栈是解释器（就像浏览器中的javascript解释器）追踪函数执行流的一种机制，是代码执行的地方，是一种拥有 LIFO（后进先出）数据结构的栈。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。

JavaScript 是一门单线程的语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。

+ 每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。
+ 正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。
+ 当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。
+ 当分配的调用栈空间被占满时，会引发“堆栈溢出”。

## 执行上下文

每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。

+ **全局执行上下文** — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
+ **函数执行上下文** — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。

在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用 Window 对象)。在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）。

  	let foo = {
	  	baz: function() {
		  console.log(this);
		  }
	}
	foo.baz();   // 'this' 引用 'foo', 因为 'baz' 被
	             // 对象 'foo' 调用
	let bar = foo.baz;
	bar();       // 'this' 指向全局 window 对象，因为
	             // 没有指定引用对象

## 原始类型

> 基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有6种基本类型：string，number，boolean，null，undefined，symbol (ECMAScript 2015新增)。

所有基本类型的值都是**不可改变**的。但需要注意的是，**基本类型本身和一个赋值为基本类型的变量的区别**。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。

### null到底是什么类型

现在很多书籍把null解释成空对象，是一个对象类型。然而在早期JavaScript的版本中使用的是32位系统，考虑性能问题，使用低位存储变量的类型信息，000开头代表对象，而null就代表全零，所以将它错误的判断成Object，虽然后期内部判断代码已经改变，**但null类型为object的判断却保留了下来**，至于null具体是什么类型，属于仁者见仁智者见智，你说它是一个bug也好，说它是空对象，是对象类型也能理解的通。

## 值类型和引用类型

> 值类型：string，number，boolean，null，undefined，symbol
> 引用类型： 对象（Object）、数组（Array）、函数（Function）

### 值类型和引用类型的区别

值类型：

+ 1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）
+ 2、保存与复制的是**值本身**
+ 3、使用**typeof**检测数据的类型
+ 4、基本类型数据是值类型

引用类型(即广义的对象类型)：

+ 1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，**这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见）**，则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）
+ 保存与复制的是指向对象的一个**指针**
+ 使用**instanceof**检测数据类型
+ 使用new()方法构造出的对象是引用型

下面用一个例子说明：

	function testPerson(person) {
	  person.age = 52;
	  person = {
	    name: '李四',
	    age: 18
	  }
	  return person;
	}
	var p1 = {
	  name: '张三',
	  age: 23
	}
	var p2 = testPerson(p1);
	console.log(p1.age);  // 输出52
	console.log(p2.age);  // 输出18

## 类型转换

原始值 | 转化为数值类型 | 转化为字符串类型 | 转化为 Boolean 类型
:-: | :-: | :-: | :-: 
false | 0 | "false" | false|
true | 1 | "true" | true|
0 | 0 | "0" | false|
false | 0 | "false" | false|


1
1
"1"
true


"0"
0
"0"
true


"1"
1
"1"
true


NaN
NaN
"NaN"
false


Infinity
Infinity
"Infinity"
true


-Infinity
-Infinity
"-Infinity"
true


""
0
""
false


"20"
20
"20"
true


"twenty"
NaN
"twenty"
true


[ ]
0
""
true


[20]
20
"20"
true


[10,20]
NaN
"10,20"
true


["twenty"]
NaN
"twenty"
true


["ten","twenty"]
NaN
"ten,twenty"
true


function(){}
NaN
"function(){}"
true


{ }
NaN
"[object Object]"
true


null
0
"null"
false


undefined
NaN
"undefined"
false



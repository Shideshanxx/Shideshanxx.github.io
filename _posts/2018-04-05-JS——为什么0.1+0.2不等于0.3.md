---
layout:     post
title:      "JS——为什么0.1+0.2不等于0.3"
subtitle:   "计算机数据存储，JS浮点数精度"
date:       2018-04-05
author:     "Deshan Shi"
tags:       [Javascript]
categories : [前端]
header-img: "/img/post/post-bg-js-version.jpg"
description: "在JS中不要轻易测试某个特定的浮点数值"
---

## 目录
{: .no_toc}

* 目录
{:toc}

## 前言

先看两个比较诡异的代码

	0.1 + 0.2 > 0.3 // true
	0.1 * 0.1 = 0.010000000000000002

为什么0.1+0.2不等于0.3？为什么0.1*0.1不等于0.01？且看下文分解。

## 计算机内部存储数据

我们都知道，计算机用位来储存及处理数据。

### 计算机内部如何表示整数

这里以十进制数13来展示“按位计数法”如何表示整数：

![十进制](https://i.loli.net/2019/03/16/5c8c9124299e9.png)

没有误差，精确地显示出来

### 计算机内部如何表示小数

这里以十进制数0.1来展示“按位计数法”如何表示小数：

	十进制数0.1以十进制按位计数法表示为：0.01
	十进制数0.1以二进制按位计数法表示为：0.0001100011....

按二进制，它是一个无限循环小数，但计算机有精度限制，不可能储存所有小数数位，所以它并不是一个精确的值。

### 如何用二进制表示0.1

关于十进制与二进制间如何转换，这里不细说，直接给出结论：

**十进制整数转二进制方法：除2取余；十进制小数转二进制方法：乘2除整**

十进制0.1转换成二进制，乘2取整过程：

	0.1 * 2 = 0.2 # 0
	0.2 * 2 = 0.4 # 0
	0.4 * 2 = 0.8 # 0
	0.8 * 2 = 1.6 # 1
	0.6 * 2 = 1.2 # 1
	0.2 * 2 = 0.4 # 0
	0.4 * 2 = 0.8 # 0
	.....

从上面可以看出，0.1的二进制格式是：0.0001100011....。这是一个二进制无限循环小数，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？

答案是：在某个精度点直接舍弃（**JS中浮点数值的最高精度是17位小数**）。当然，代价就是，0.1在计算机内部根本就不是精确的0.1，而是一个有舍入误差的0.1。当代码被编译或解释后，0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于0.3以及0.1*0.1不等于0.001 的原因。

### 如何用二进制表示0.5

	0.5 * 2 = 1 # 1

0.5的二进制格式是：0.1 ，不存在误差。

## 结论

+ 为什么0.1 + 0.2 不等于0.3。因为计算机不能精确表示0.1， 0.2这样的浮点数，计算时使用的是带有舍入误差的数
+ 并不是所有的浮点数在计算机内部都存在舍入误差，比如0.5就没有舍入误差
+ 永远不要测试某个特定浮点数值，不要直接比较两个浮点数
+ 可以尝试使用整型代替浮点数计算
---
layout:     post
title:      "Vue——Vue基础知识汇总"
subtitle:   "Vue基础知识汇总"
date:       2019-05-05
author:     "Deshan Shi"
tags:       [Vue]
categories : [前端]
header-img: "/img/post/vue03.jpg"
description: "vue的官方文档对Vue的一些基础知识做了比较详细的介绍，为了巩固自己的Vue基础，写了这篇文章"
---

## 目录
{: .no_toc}

* 目录
{:toc}

## MVVM模式

MVVM是Model-View-ViewModel的缩写，其核心是提供对View和ViewModel的双向数据绑定。既ViewModel的状态改变可以自动传递给View，也就是所谓的数据双向绑定。

![MVVM示意图](https://i.loli.net/2019/06/27/5d1437012b38586226.png)

View层：

	<div id="app">
	  <input type="text" v-model="inputValue">
	  <button @click="handleSubmitClick">提交</button>
	  <ul>
	    <li v-for="(item,index) of list" :key="index">{{item}}</li>
	  </ul>
	</div>

Model层：

	<script src="./vue.js"></script>
	<script>
	  // Model(数据)  View(页面)  VM(vue.js)
	  var app = new Vue({
	    el: '#app',
	    data() {
	      return {
	        list: [],
	        inputValue: ''
	      }
	    },
	    methods: {
	      handleSubmitClick() {
	        this.list.push(this.inputValue);
	        this.inputValue = '';
	      }
	    }
	  })
	</script>

## 安装

Vue.js安装方式有很多种，它也有很多的版本，例如：

+ 可以通过script标签引入
+ 可以通过npm引入
+ 可以通过其他方式引入，为了学习的方便，我们通常使用script标签来引入vue.js开发版本。

## Vue实例

每一个Vue应用都会通过new Vue()的方式构造一个Vue实例，一个大型的Vue项目，往往由一个Vue根实例和一些可选组件实例所构成。

### 实例属性和方法

Vue实例在被创建的时候，只有在data中声明的变量才会是响应式的，实例在被创建之后，实例上会有一些实例属性和方法，当然用户在data中定义的变量也被挂载到了Vue实例上。

	// vue实例
	var app = new Vue({
	  el: '#app',
	  data() {
	    return {
	      message: 'hello,world',
	      age: 23,
	      name: 'AAA'
	    }
	  }
	})
	
	// 实例属性和方法
	console.log(app.$data)
	console.log(app.$data.age)
	console.log(app.$el)
	
	// 只有在data中声明的属性才是响应式的
	app.address = '广州'; // 这个属性不是响应式的
	app.age = 32; // 这个属性是响应式的

## Vue生命周期

> **理解**

> Vue实例的生命周期就是：Vue实例在某一个时间点会自动执行的函数。Vue生命周期有11种之多，它分为不同的组。
> 
> + beforeCreate和created这两个钩子函数，会在Vue实例被创建之前和创建后分别调用
> + beforeMount和mounted这两个钩子函数，会在模板和数据相结合被挂载到页面之前和之后分别调用
> + beforeUpdate和updated这两个钩子函数，会在数据发生变化之前和之后分别调用
> + beforeDestory和destory这两个钩子函数，会在Vue实例被销毁之前和销毁之后分别调用
> + activated和deactivated这两个钩子函数，会在keep-alive组件激活和停用时分别调用
> + errorCaptured会在捕获子组件、孙组件发生错误时触发(2.5.0+版本新增)

生命周期的使用：

	var app = new Vue({
	  el: '#app',
	  data() {
	    return {
	      message: 'hello,world',
	    }
	  },
	  beforeCreate() {
	    console.log('beforeCreate')
	  },
	  created() {
	    console.log('created');
	  },
	  beforeMount() {
	    console.log('beforeMount');
	  },
	  mounted() {
	    console.log('mounted');
	  },
	  beforeUpdate() {
	    console.log('beforeUpdate');
	  },
	  updated() {
	    console.log('updated');
	  },
	  beforeDestory() {
	    console.log('beforeDestory');
	  },
	  destoryed() {
	    console.log('destoryed');
	  }
	})

## Vue模板语法

### 插值

Vue的模板语法常见绑定值的方式有很多种，常见的三种它们各自的特点如下：

+ 使用Mustache来实现插值，即可以只是一个变量，也可以是一个js表达式
+ 使用v-text指令来实现插值，它的作用同Mustache类似，同样也可以是一个js表达式
+ 使用v-html指令也能实现插值，它的作用是将原始的差值进行原始html解析

举例分析：

	<p>{{message}}</p>
	<p v-text="message"></p>
	<p v-html="message"></p>
	<p v-text="rawHTML"></p>
	<p v-html="rawHTML"></p>

	var app = new Vue({
	  el: '#app',
	  data() {
	    return {
	      message: 'hello,world',
	      rawHTML: '<h1>hello,world</h1>'
	    }
	  },
	})

![v-text&v-html](https://i.loli.net/2019/06/27/5d143eb17e8ae27823.png)

### 指令

Mustache语法不能作用于某些html特性上，这个时候，指令就派上了用处，常见的指令有:

+ v-bind：它的作用是绑定一个html标签特性，例如：<button v-bind:id='btn'></button>
+ v-on: 它的作用是绑定一个html标签的事件，例如：<button v-on:click='handleBtnClick'></button>
+ v-if：它的作用是根据某个变量的boolean值，进行控制此元素是否在html文档上出现
+ v-show：它的作用同v-if类似，不过两者之间最本质的差别是，v-show是通过css属性display:none来控制元素是否显示。
+ 其他自定义指令

eg：

	<!-- v-bind -->
	<button v-bind:id="submitBtn">按钮</button>
	
	<!-- v-on -->
	<button v-on="handleBtnClick">按钮</button>
	
	<!-- v-if -->
	<p v-if="isShow">v-if元素标签</p> 
	
	<!-- v-show -->
	<p v-show="isShow">v-show元素标签</p>

	var app = new Vue({
	  el: '#app',
	  data() {
	    return {
	      isShow: false
	    }
	  },
	  methods: {
	    handleBtnClick() {
	      console.log('v-on click');
	    }
	  }
	})

运行结果：

![指令的运行结果](https://i.loli.net/2019/06/27/5d144033c4c7938493.png)

### 缩写

> **TIP**

> + v-bind的缩写形式是:bind
> + v-on的缩写形式是@on

	<!-- v-bind的缩写 -->
	<button v-bind:id="submitBtn"></button>
	<button :id="submitBtn"></button>
	
	<!-- v-on的缩写 -->
	<button v-on="handleBtnClick"></button>
	<button @click="handleBtnClick"></button>

## 计算属性、方法和监听器

### 计算属性

> **TIP**

> 在Mustache语法中，它允许我们书写一些js逻辑在里面，对于一些简单的逻辑，书写在Mustache语法中是非常合适的，但对于复杂的逻辑，就十分不合适了，这个就是计算属性能帮到我们。计算属性是基于它的依赖进行缓存的，意思是只要你依赖的变量的值不发生变化，计算属性永远只会计算这一次。

	<div id="app">
	  <!-- 输出：Hello，world -->
	  {{fullName}}
	</div>

	<script src="./vue.js"></script>
	<script>
	  var app = new Vue({
	    el: '#app',
	    data() {
	      return {
	        firstName: 'Hello，',
	        lastName: 'world'
	      }
	    },
	    computed: {
	      fullName() {
	        return this.firstName + this.lastName;
	      }
	    }
	  })
	</script>

### 计算属性vs方法

> **TIP**

> 一些计算属性能够做到的事情，使用方法同样能够做到，但就像上面所讲到的那样：**计算属性是基于它的依赖而进行缓存的，相反使用方法的话，它会每次都计算一次**，对于一些开销较大的逻辑，我们更推荐使用计算属性而不是方法。

	<div id="app">
	  计算属性：{{reverseMsg}}<br/>
	  方法：{{reverseMsgMethods()}}
	</div>
	var app = new Vue({
	  el: '#app',
	  data() {
	    return {
	      msg: 'hello,world'
	    }
	  },
	  computed: {
	    reverseMsg() {
	      return this.msg.split('').reverse().join('');
	    }
	  },
	  methods: {
	    reverseMsgMethods() {
	      return this.msg.split('').reverse().join('');
	    }
	  }
	})

运行结果：

	计算属性：dlrow,olleh
	方法：dlrow,olleh

### 计算属性vs监听属性

> **TIP**

> 监听属性**watch**作用是当监听的属性值发生改变时，随后执行什么操作。

	<div id="app">
	  计算属性：{{fullName}}<br/>
	  监听属性：{{fullNameWatch}}
	</div>
	var app = new Vue({
	  el: '#app',
	  data() {
	    return {
	      firstName: 'foo',
	      lastName: 'bar',
	      fullNameWatch: 'foo bar'
	    }
	  },
	  computed: {
	    fullName() {
	      return this.firstName + ' ' + this.lastName;
	    }
	  },
	  watch: {
	    firstName(val) {
	      this.fullNameWatch = val + ' ' + this.lastName;
	    },
	    lastName(val) {
	      this.fullNameWatch = this.firstName + ' ' + val;
	    }
	  }
	})

运算结果：

![watch&computed](https://i.loli.net/2019/06/27/5d14452f4c90826201.png)

### 计算属性的getter和setter

> **TIP**

> 计算属性默认只有getter，当然你也可以添加一个setter，它们分别会在读取计算属性和设置计算属性时被调用

	<div id="app">
	  计算属性的get和set：{{fullName}}<br/>
	</div>
	var app = new Vue({
	  el: '#app',
	  data() {
	    return {
	      firstName: 'foo',
	      lastName: 'bar'
	    }
	  },
	  computed: {
	    fullName: {
	      get() {
	        return this.firstName + ' ' + this.lastName;
	      },
	      set(val) {
	        let names = val.split(' ');
	        this.firstName = names[0];
	        this.lastName = names[names.length-1];
	      }
	    }
	  }
	})

运算结果：

![computed's getter&setter](https://i.loli.net/2019/06/27/5d1445fc7894826387.png)

### Class和Style绑定

> **TIP**

> 无论是class还是style的样式绑定，除了字符串类型，还可以是数组或者对象

#### 绑定Class


